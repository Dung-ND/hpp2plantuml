#+TITLE: hpp-to-plantuml Convert C++ header files to PlantUML
#+DATE: <2016-11-30 Wed>
#+TODO: TODO REVIEW | DONE DEFERRED ABANDONED
#+PROPERTY: header-args+ :eval never
#+PROPERTY: header-args+ :exports code :results silent
#+PROPERTY: header-args:python+ :tangle hpptoplantuml.py

* REVIEW Motivation

The purpose of this tool is to convert C++ source code to UML diagrams that can
be used with [[https://plantuml.com][PlantUML]].

PlantUML is a program rendering UML diagrams from plain text inputs using an
expressive language.

This module generates the text input to PlantUML from C++ header files.  Its
ambition is limited but it should produce reasonable conversion for simple class
hierarchies.  It aims at supporting:
- class members with properties (=private=, =method=, =protected=), methods with
  basic qualifiers (=static=, abstract),
- inheritance relationships,
- composition relationships (very basic support).


* TODO Requirements

This module has mostly standard dependencies; the only exception is the
[[http://senexcanis.com/open-source/cppheaderparser/][CppHeaderParser]] module used to parse header files.

#+NAME: py-imports
#+BEGIN_SRC python
# %% Imports
import sys
import io
import re
import glob
import argparse
import CppHeaderParser
#+END_SRC


* TODO Render elements

The module code consists in specific rendering functions for individual
elements.


** TODO Constants

The =MEMBER_PROP_MAP= variable maps class member types to corresponding PlantUML
characters.

#+NAME: py-constants
#+BEGIN_SRC python
# %% Constants

# Association between member property and PlantUML symbol
MEMBER_PROP_MAP = {
    'private': '-',
    'public': '+',
    'protected': '#'
}
#+END_SRC

** TODO Base class

#+NAME: py-obj-container
#+BEGIN_SRC python
# %% Base classes

class Container:
    def __init__(self, container_type, name):
        self._container_type = container_type
        self._name = name
        self._member_list = []

    def parse_members(self, header_container):
        raise NotImplementedError(
            'Derived class must implement `parse_members`.')

    def render(self):
        container_str = self._render_container_def() + ' {\n'
        for member in self._member_list:
            container_str += '\t' + member.render() + '\n'
        container_str += '}\n'

    def _render_container_def(self):
        return self._container_type + ' ' + self._name

class ContainerMember:
    def __init__(self, header_member, **kwargs):
        self._name = header_member['name']

    def render(self):
        raise NotImplementedError('Derived class must implement `render`.')
#+END_SRC


** TODO Classes

Classes are rendered with the =_RenderClasses= function.  Abstract and template
classes are labeled accordingly.

Methods and properties and handled by the [[#sec_class_methods][=_RenderMethod=]] and the
[[#sec_class_properties][=_RenderProperty=]] functions respectively.  Members are also categorized by scope
(public, private, protected)

The =_RenderClasses= function also builds lists of relationships which are
rendered after all files have been processed:
- a list of member variable types, used to establish the composition
  relationships between classes,
- an inheritance list


#+NAME: py-render-classes
#+BEGIN_SRC python
# %% Class object

class Class(Container):
    def __init__(self, header_class):
        super().__init__('class', header_class['name'])
        self.parse_members(header_class)
        self._abstract = header_class['abstract']
        self._template_type = None
        if 'template' in header_class['template']:
            self._template_type = header_class['template']
        self._inheritance_list = [parent['class']
                                  for parent in header_class['inherits']]
        self.parse_members(header_class)

    def parse_members(self, header_class):
        member_type_map = [
            ['properties', lambda item, prop: ClassVariable(item, prop)],
            ['methods', lambda item, prop:  ClassMethod(item, prop)]
        ]
        for member_type, member_type_handler in member_type_map:
            for member_prop in MEMBER_PROP_MAP.keys():
                member_list = header_class[member_type][member_prop]
                for header_member in member_list:
                    self._member_list.append(
                        member_type_handler(header_member, member_prop))

    def build_variable_type_list(self):
        variable_type_list = []
        for member in self._member_list:
            if isinstance(member, ClassVariable):
                variable_type_list.append(member.get_type())
        return variable_type_list

    def build_inheritance_list(self):
        return self._inheritance_list

    def _render_container_def(self):
        class_str = self._container_type + ' ' + self._name
        if self._abstract:
            class_str = 'abstract ' + class_str
        if self._template_type is not None:
            class_str += ' <{0}>'.format(self._template_type)
        return class_str
#+END_SRC

** TODO Enums

Enumeration lists rendering is trivial.  Note that the enumeration elements are
rendered without the actual values.

#+NAME: py-render-enums
#+BEGIN_SRC python
# %% Enum object
class Enum(Container):
    def __init__(self, header_enum):
        super().__init__('enum', header_enum['name'])
        self.parse_members(header_enum)

    def parse_members(self, header_enum):
        for value in header_enum['values']:
            self._member_list += EnumValue(value)


class EnumValue(ContainerMember):
    def __init__(self, header_value, **kwargs):
        super().__init__(header_value)

    def render(self):
        return self._name
#+END_SRC


** TODO Class members

#+NAME: py-obj-class_member
#+BEGIN_SRC python
# %% Class member
class ClassMember(ContainerMember):
    def __init__(self, class_member, member_scope='private'):
        super().__init__(class_member['name'])
        self._type = None
        self._static = class_member['static']
        self._scope = member_scope

    def render(self):
        member_str = MEMBER_PROP_MAP[self._scope] + \
                      ('{static} ' if self._static else '') + \
                      self._render_name() + \
                      (' : ' + self._type if self._type else '')
        return member_str

    def _render_name(self):
        return self._name
#+END_SRC


*** TODO Properties
    :PROPERTIES:
    :CUSTOM_ID: sec_class_properties
    :END:

#+NAME: py-obj-class_variable
#+BEGIN_SRC python
# %% Class variable
class ClassVariable(ClassMember):
    def __init__(self, class_variable, member_scope='private'):
        assert(isinstance(class_variable,
                          CppHeaderParser.CppHeaderParser.CppVariable))

        super().__init__(class_variable, member_scope)

        self._type = _cleanup_type(class_variable['type'])

    def get_type(self):
        return self._type
#+END_SRC


*** TODO Methods
    :PROPERTIES:
    :CUSTOM_ID: sec_class_methods
    :END:

#+NAME: py-obj-class_method
#+BEGIN_SRC python
# %% Class method
class ClassMethod(ClassMember):
    def __init__(self, class_method, member_scope):
        assert(isinstance(class_method,
                          CppHeaderParser.CppHeaderParser.CppMethod))

        super().__init__(class_method, member_scope)

        self._type = _cleanup_type(class_method['returns'])
        self._abstract = class_method['pure_virtual']
        if class_method['destructor']:
            self._name = '~' + self._name
        self._param_list = []
        for param in class_method['parameters']:
            self._param_list.append([_cleanup_type(param['type']),
                                     param['name']])

    def _render_name(self):
        assert(not self._static or not self._abstract)

        method_str = ('{abstract} ' if self._abstract else '') + \
                     self._name + '(' + \
                     ', '.join(' '.join(it) for it in self._param_list) + ')'

        return method_str
#+END_SRC


** TODO Preamble / postamble

PlantUML files start with =@startuml= and end with =@enduml=.  This is handled
by the preamble and postamble functions.

#+NAME: py-pre-post-amble
#+BEGIN_SRC python
# %% PlantUML wrapper strings
def _Preamble():
    return '@startuml\n'

def _Postamble():
    return '\n@enduml\n'
#+END_SRC


** TODO Diagram object

#+NAME: py-obj-diagram
#+BEGIN_SRC python
# %% Diagram class

class Diagram:
    def __init__(self, file_list):
        container_type_map = [
            ['classes', lambda item: Class(item)],
            ['enums', lambda item: Enum(item)]
        ]
        self._objects = []

        for header_file in file_list:
            # Parse header file
            parsed_header = CppHeaderParser.CppHeader(header_file)
            for container_type, container_handler in container_type_map:
                objects = parsed_header.__getattribute__(container_type)
                container_handler(objects)

#+END_SRC

** TODO Individual header file

#+NAME: py-render-header
#+BEGIN_SRC python
def _RenderFile(header_file, fid, link_list):
    # Types of objects
    type_map = [
        ['classes', lambda items, f, l: _RenderClasses(items, f, l)],
        ['enums', lambda items, f, l: _RenderEnums(items, f, l)]
    ]

    # Parse header file
    parsed_header = CppHeaderParser.CppHeader(header_file)
    for obj_type, obj_str_f in type_map:
        objs = parsed_header.__getattribute__(obj_type)
        obj_str_f(objs, fid, link_list)
#+END_SRC


** TODO Relationships

*** TODO Render inheritance links

#+NAME: py-render-inherit
#+BEGIN_SRC python
# %% Render inheritance links
def _RenderInheritLinks(inherit_link_dict, fid):
    for child, parents in inherit_link_dict.items():
        for parent in parents:
            fid.write('\n' + parent + ' <|-- ' + child + '\n')
#+END_SRC

*** TODO Render composition links

#+NAME: py-helper-composition-gather
#+BEGIN_SRC python
# %% Build list of composition links
def _BuildCompLinks(link_list):
    for class_obj in link_list['classes_comp'].keys():
        prop_types = link_list['property_types'][class_obj]
        for prop_type in prop_types:
            for class_member in link_list['classes_comp'].keys():
                if re.search(r'\b' + class_member + r'\b', prop_type,
                             flags=re.IGNORECASE):
                    if len(link_list['classes_comp'][class_obj]) == 0 or \
                       class_member not in \
                       [c[0] for c in link_list['classes_comp'][class_obj]]:
                        link_list['classes_comp'][class_obj].append(
                            [class_member, 1])
                    else:
                        idx = [c[0] for c in
                               link_list['classes_comp'][class_obj]].index(
                                   class_member)
                        link_list['classes_comp'][class_obj][idx][1] += 1
#+END_SRC

#+NAME: py-render-composition
#+BEGIN_SRC python
# %% Render composition links
def _RenderCompLinks(comp_link_dict, fid):
    for class_parent, class_children in comp_link_dict.items():
        for class_child, child_count in class_children:
            count_str = '' if child_count == 1 else ' "%d"' % child_count
            fid.write('\n' + class_parent + count_str + ' *-- ' +
                      class_child + '\n')

#+END_SRC



* TODO Helper functions

** TODO Sanitize type string

#+NAME: py-helper-cleanup-str
#+BEGIN_SRC python
def _cleanup_type(type_str):
    return re.sub(r'[ ]+\*', '*',
                  re.sub(r'(\s)+', r'\1', type_str))
#+END_SRC


** TODO Expand file list

#+NAME: py-build-file-list
#+BEGIN_SRC python
def _ExpandFileList(input_files):
    """ Find all in list (expanding wildcards)

    Uses `glob` to list matching files.
    """
    file_list = []
    for input_file in input_files:
        file_list += glob.glob(input_file)
    return file_list
#+END_SRC


* TODO Process input files

** TODO Render objects

#+NAME: py-create-plantuml
#+BEGIN_SRC python
def CreatePlantUMLFile(file_list, output_file):
    """ Create PlantUML file from list of header files
    """
    # List of relationships
    link_list = {}
    with open(output_file, 'wt') as fid:
        fid.write(_Preamble() + '\n')

        # Objects
        for header_file in file_list:
            _RenderFile(header_file, fid, link_list)

        # Inheritance
        _RenderInheritLinks(link_list['inherits'], fid)

        # Composition
        _BuildCompLinks(link_list)
        _RenderCompLinks(link_list['classes_comp'], fid)

        fid.write(_Postamble() + '\n')

#+END_SRC


* TODO Command line mode

#+NAME: py-parse-inputs
#+BEGIN_SRC python
# %% Standalone mode

def main():
    parser = argparse.ArgumentParser(description='hpp-to-plantuml tool.')
    parser.add_argument('-o', '--output-file', dest='output_file',
                        required=True, metavar='FILE', help='Output file')
    parser.add_argument('-i', '--input-file', dest='input_files',
                        action='append', metavar='HEADER-FILE', required=True,
                        help='Input file')
    args = parser.parse_args()
    input_file_list = _ExpandFileList(args.input_files)
    if len(input_file_list) > 0:
        CreatePlantUMLFile(input_file_list, args.output_file)

if __name__ == '__main__':
    main()
#+END_SRC


* TODO Tests

** TODO Input files

#+NAME: hpp-simple-classes
#+BEGIN_SRC c++ :mkdirp yes :tangle test/simple-classes.hpp

enum Enum01 { VALUE_0, VALUE_1, VALUE_2 };

class Class01 {
protected:
	int _protected_var;
	bool _ProtectedMethod(int param);
	static bool _StaticProtectedMethod(bool param);
	virtual bool _AbstractMethod(int param) = 0;
public:
	int public_var;
	bool PublicMethod(int param);
	static bool StaticPublicMethod(bool param);
	virtual bool AbstractPublicMethod(int param) = 0;
};

class Class02 : public Class01 {
public:
	bool AbstractPublicMethod(int param) override;
private:
	int _private_var;
	bool _PrivateMethod(int param);
	static bool _StaticPrivateMethod(bool param);
	bool _AbstractMethod(int param) override;
};

template<typename T>
class Class03 {
public:
	Class03();
	~Class03();
private:
	Class01* _obj;
	list<Class02> _obj_list;
	T* _typed_obj;
};
#+END_SRC

